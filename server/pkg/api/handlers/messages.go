package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"progressdb/pkg/auth"
	"progressdb/pkg/logger"
	"progressdb/pkg/models"
	"progressdb/pkg/store"
	"progressdb/pkg/utils"
	"progressdb/pkg/validation"

	"go.uber.org/zap"

	"sort"

	"github.com/gorilla/mux"
)

// RegisterMessages registers HTTP handlers for message-related endpoints.
// This includes endpoints for creating, listing, retrieving, updating, and deleting messages,
// as well as managing message versions and reactions.
func RegisterMessages(r *mux.Router) {
	// /v1/messages
	r.HandleFunc("/messages", createMessage).Methods(http.MethodPost)
	r.HandleFunc("/messages", listMessages).Methods(http.MethodGet)

	// /v1/messages/{id}
	r.HandleFunc("/messages/{id}", getMessage).Methods(http.MethodGet)
	r.HandleFunc("/messages/{id}", updateMessage).Methods(http.MethodPut)
	r.HandleFunc("/messages/{id}", deleteMessage).Methods(http.MethodDelete)
	r.HandleFunc("/messages/{id}/versions", listMessageVersions).Methods(http.MethodGet)

	// /v1/messages/{id}/reactions
	r.HandleFunc("/messages/{id}/reactions", getReactions).Methods(http.MethodGet)
	r.HandleFunc("/messages/{id}/reactions", addReaction).Methods(http.MethodPost)
	r.HandleFunc("/messages/{id}/reactions/{identity}", deleteReaction).Methods(http.MethodDelete)
}

// createMessage handles POST /messages to create a new message.
// Request body: JSON object representing a models.Message.
// Required fields in body: "body" (string), "author" (string).
// Optional fields: "thread" (string, if omitted a new thread is created), "id" (string, autogenerated if omitted), "ts" (int64, autogenerated if omitted).
// Response: 200 with created message JSON, or 400/500 on error.
func createMessage(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	var m models.Message
	if err := json.NewDecoder(r.Body).Decode(&m); err != nil {
		http.Error(w, `{"error":"invalid json"}`, http.StatusBadRequest)
		return
	}
	// determine caller role and canonical author
	// resolve canonical author (from signature, or backend-provided body/header)
	if author, code, msg := auth.ResolveAuthorFromRequest(r, m.Author); code != 0 {
		http.Error(w, msg, code)
		return
	} else {
		m.Author = author
	}
	// Ensure message role is present. Default to "user" when omitted.
	if m.Role == "" {
		m.Role = "user"
	}
	// If no thread provided, create one explicitly via createThreadInternal
	if m.Thread == "" {
		th, err := createThreadInternal(m.Author, defaultThreadTitle())
		if err != nil {
			http.Error(w, `{"error":"failed to create thread"}`, http.StatusInternalServerError)
			return
		}
		// sync thread to message
		m.Thread = th.ID
	} else {
		// ensure provided thread exists and user is the author
		s, err := store.GetThread(m.Thread)
		if err != nil {
			http.Error(w, `{"error":"thread not found"}`, http.StatusNotFound)
			return
		}
		var th models.Thread
		if err := json.Unmarshal([]byte(s), &th); err != nil {
			http.Error(w, `{"error":"failed to parse thread"}`, http.StatusInternalServerError)
			return
		}
		// Only allow creating if the user is the author, unless admin
		role := r.Header.Get("X-Role-Name")
		if role != "admin" && th.Author != m.Author {
			http.Error(w, `{"error":"author does not match thread"}`, http.StatusForbidden)
			return
		}
	}

	// generate a message id
	m.ID = utils.GenID()
	if m.TS == 0 {
		m.TS = time.Now().UTC().UnixNano()
	}

	// prevent posting to deleted thread
	if sthr, err := store.GetThread(m.Thread); err == nil {
		var th models.Thread
		if err := json.Unmarshal([]byte(sthr), &th); err == nil {
			if th.Deleted && r.Header.Get("X-Role-Name") != "admin" {
				http.Error(w, `{"error":"thread deleted"}`, http.StatusForbidden)
				return
			}
		}
	}

	// validate the message format
	if err := validation.ValidateMessage(m); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusBadRequest)
		return
	}

	// At this point the thread exists (we either created it above & validated the provided thread id & message).
	// lets store the message
	if err := store.SaveMessage(m.Thread, m.ID, m); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	logger.Log.Info("message_created", zap.String("thread", m.Thread), zap.String("id", m.ID))
	_ = json.NewEncoder(w).Encode(m)
}

// listMessages handles GET /messages to list messages in a thread.
// Query parameters:
//   - "thread" (string, optional): thread ID to list messages from (default: "default").
//   - "limit" (int, optional): maximum number of most recent messages to return.
//
// Response: 200 with JSON object {thread, messages}, or 500 on error.
func listMessages(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	threadID := r.URL.Query().Get("thread")
	if threadID == "" {
		threadID = "default"
	}
	msgs, err := store.ListMessages(threadID)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	if limStr := r.URL.Query().Get("limit"); limStr != "" {
		if lim, err := strconv.Atoi(limStr); err == nil && lim >= 0 && lim < len(msgs) {
			msgs = msgs[len(msgs)-lim:]
		}
	}
	// Build map of latest version per message id, then optionally filter deleted
	includeDeleted := r.URL.Query().Get("include_deleted") == "true"
	latest := make(map[string]models.Message)
	for _, s := range msgs {
		var mm models.Message
		if err := json.Unmarshal([]byte(s), &mm); err != nil {
			continue
		}
		cur, ok := latest[mm.ID]
		if !ok || mm.TS >= cur.TS {
			latest[mm.ID] = mm
		}
	}
	// Collect and sort by timestamp ascending
	out := make([]models.Message, 0, len(latest))
	for _, v := range latest {
		if v.Deleted && !includeDeleted {
			continue
		}
		out = append(out, v)
	}
	// sort by TS
	sort.Slice(out, func(i, j int) bool { return out[i].TS < out[j].TS })
	logger.Log.Info("messages_list", zap.String("thread", threadID), zap.Int("count", len(out)))
	_ = json.NewEncoder(w).Encode(struct {
		Thread   string           `json:"thread"`
		Messages []models.Message `json:"messages"`
	}{Thread: threadID, Messages: out})
}

// getMessage handles GET /messages/{id} to retrieve the latest version of a message by ID.
// Path parameter: "id" (string, required): message ID.
// Response: 200 with message JSON, or 404 if not found.
func getMessage(w http.ResponseWriter, r *http.Request) {
	// set response content type to json
	w.Header().Set("Content-Type", "application/json")

	// extract message id from url path variables
	id := mux.Vars(r)["id"]

	// retrieve the latest version of the message from the store
	s, err := store.GetLatestMessage(id)
	if err != nil {
		// if not found, return 404 with error message
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}

	// write the message json to the response
	_, _ = w.Write([]byte(s))
}

// updateMessage handles PUT /messages/{id} to update a message by ID.
// Path parameter: "id" (string, required): message ID.
// Request body: JSON object representing a models.Message.
// Required fields in body: "body" (string), "author" (string).
// Optional fields: "thread" (string, if omitted a new thread is created), "ts" (int64, autogenerated if omitted).
// Response: 200 with updated message JSON, or 400/500 on error.
func updateMessage(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	id := mux.Vars(r)["id"]
	var m models.Message
	if err := json.NewDecoder(r.Body).Decode(&m); err != nil {
		http.Error(w, `{"error":"invalid json"}`, http.StatusBadRequest)
		return
	}
	m.ID = id
	// Ensure role is present; default to "user" if omitted
	if m.Role == "" {
		m.Role = "user"
	}

	// If thread omitted in update payload, inherit from existing message.
	if m.Thread == "" {
		sOld, err := store.GetLatestMessage(id)
		if err != nil {
			http.Error(w, `{"error":"message not found"}`, http.StatusNotFound)
			return
		}
		var old models.Message
		_ = json.Unmarshal([]byte(sOld), &old)
		m.Thread = old.Thread
	}
	if m.TS == 0 {
		m.TS = time.Now().UTC().UnixNano()
	}
	if err := validation.ValidateMessage(m); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusBadRequest)
		return
	}
	// Ensure thread exists
	if _, err := store.GetThread(m.Thread); err != nil {
		http.Error(w, `{"error":"thread not found"}`, http.StatusNotFound)
		return
	}

	b, _ := json.Marshal(m)
	if err := store.SaveMessage(m.Thread, m.ID, string(b)); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	_ = json.NewEncoder(w).Encode(m)
}

// deleteMessage handles DELETE /messages/{id} to mark a message as deleted.
// Path parameter: "id" (string, required): message ID.
// Response: 204 No Content on success, 404 if not found, or 500 on error.
func deleteMessage(w http.ResponseWriter, r *http.Request) {
	// extract message ID from path
	w.Header().Set("Content-Type", "application/json")
	id := mux.Vars(r)["id"]

	// fetch the latest message from the store
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}

	// unmarshal the stored message JSON
	var m models.Message
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		http.Error(w, `{"error":"invalid stored message"}`, http.StatusInternalServerError)
		return
	}

	// verify author owns the message (or is admin)
	author, code, msg := auth.ResolveAuthorFromRequest(r, "")
	if code != 0 {
		http.Error(w, msg, code)
		return
	}
	role := r.Header.Get("X-Role-Name")
	if role != "admin" && m.Author != author {
		http.Error(w, `{"error":"author does not match"}`, http.StatusForbidden)
		return
	}

	// mark as deleted and update timestamp
	m.Deleted = true
	m.TS = time.Now().UTC().UnixNano()
	b, _ := json.Marshal(m)

	// save the updated message
	if err := store.SaveMessage(m.Thread, m.ID, string(b)); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}

	// respond with 200 and deleted id
	_ = json.NewEncoder(w).Encode(struct {
		ID string `json:"id"`
	}{ID: m.ID})
}

// listMessageVersions handles GET /messages/{id}/versions to list all versions of a message.
// Path parameter: "id" (string, required): message ID.
// Response: 200 with JSON object {id, versions}, or 500 on error.
func listMessageVersions(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	id := mux.Vars(r)["id"]
	vs, err := store.ListMessageVersions(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	// Return versions as JSON objects (not JSON-encoded strings). Convert
	// stored JSON strings to json.RawMessage so the encoder emits objects.
	out := make([]json.RawMessage, 0, len(vs))
	for _, s := range vs {
		out = append(out, json.RawMessage(s))
	}
	_ = json.NewEncoder(w).Encode(struct {
		ID       string            `json:"id"`
		Versions []json.RawMessage `json:"versions"`
	}{ID: id, Versions: out})
}

// getReactions handles GET /messages/{id}/reactions to list all reactions for a message.
// Path parameter: "id" (string, required): message ID.
// Response: 200 with JSON object {id, reactions}, or 404/500 on error.
func getReactions(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	id := mux.Vars(r)["id"]
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}
	var m models.Message
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		http.Error(w, `{"error":"invalid stored message"}`, http.StatusInternalServerError)
		return
	}
	out := make([]struct {
		ID       string `json:"id"`
		Reaction string `json:"reaction"`
	}, 0)
	for k, v := range m.Reactions {
		out = append(out, struct {
			ID       string `json:"id"`
			Reaction string `json:"reaction"`
		}{ID: k, Reaction: v})
	}
	_ = json.NewEncoder(w).Encode(struct {
		ID        string      `json:"id"`
		Reactions interface{} `json:"reactions"`
	}{ID: id, Reactions: out})
}

// addReaction handles POST /messages/{id}/reactions to add or update a reaction for a message.
// Path parameter: "id" (string, required): message ID.
// Request body: JSON object with fields:
//   - "id" (string, required if X-Identity header not set): identity of the reactor
//   - "reaction" (string, required): the reaction value
//
// Alternatively, "id" can be provided via the "X-Identity" header.
// Response: 200 with updated message JSON, or 400/404/500 on error.
func addReaction(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	id := mux.Vars(r)["id"]
	var payload struct {
		ID       string `json:"id"`
		Reaction string `json:"reaction"`
	}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		http.Error(w, `{"error":"invalid json"}`, http.StatusBadRequest)
		return
	}
	identity := payload.ID
	if identity == "" {
		identity = r.Header.Get("X-Identity")
	}
	if identity == "" || payload.Reaction == "" {
		http.Error(w, `{"error":"missing id or reaction"}`, http.StatusBadRequest)
		return
	}
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}
	var m models.Message
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		http.Error(w, `{"error":"invalid stored message"}`, http.StatusInternalServerError)
		return
	}
	if m.Reactions == nil {
		m.Reactions = map[string]string{}
	}
	m.Reactions[identity] = payload.Reaction
	m.TS = time.Now().UTC().UnixNano()
	b, _ := json.Marshal(m)
	if err := store.SaveMessage(m.Thread, m.ID, string(b)); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	_ = json.NewEncoder(w).Encode(m)
}

// deleteReaction handles DELETE /messages/{id}/reactions/{identity} to remove a reaction from a message.
// Path parameters:
//   - "id" (string, required): message ID
//   - "identity" (string, required): identity of the reactor whose reaction should be removed
//
// Response: 204 No Content on success, 404 if not found, or 500 on error.
func deleteReaction(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	vars := mux.Vars(r)
	id := vars["id"]
	identity := vars["identity"]
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}
	var m models.Message
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		http.Error(w, `{"error":"invalid stored message"}`, http.StatusInternalServerError)
		return
	}
	if m.Reactions != nil {
		delete(m.Reactions, identity)
	}
	m.TS = time.Now().UTC().UnixNano()
	b, _ := json.Marshal(m)
	if err := store.SaveMessage(m.Thread, m.ID, string(b)); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}
