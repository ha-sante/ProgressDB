package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"progressdb/pkg/auth"
	"progressdb/pkg/logger"
	"progressdb/pkg/models"
	"progressdb/pkg/store"
	"progressdb/pkg/telemetry"
	"progressdb/pkg/utils"
	"progressdb/pkg/validation"

	"sort"

	"github.com/gorilla/mux"
)

// RegisterMessages registers HTTP handlers for message-related endpoints.
// This includes endpoints for creating, listing, retrieving, updating, and deleting messages,
// as well as managing message versions and reactions.
func RegisterMessages(r *mux.Router) {
	// /v1/messages
	r.HandleFunc("/messages", createMessage).Methods(http.MethodPost)
	r.HandleFunc("/messages", listMessages).Methods(http.MethodGet)
}

// createMessage handles POST /messages to create a new message.
// Request body: JSON object representing a models.Message.
// Required fields in body: "body" (string), "author" (string).
// Optional fields: "thread" (string, if omitted a new thread is created), "id" (string, autogenerated if omitted), "ts" (int64, autogenerated if omitted).
// Response: 200 with created message JSON, or 400/500 on error.
func createMessage(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	ctx := r.Context()
	// mark top-level op for request telemetry
	telemetry.SetRequestOp(ctx, "create_message")
	// top-level span for this handler (will be a child of request root when sampled)
	defer telemetry.StartSpan(ctx, "create_message.handler")()

	var m models.Message
	// decode body
	decodeSpan := telemetry.StartSpan(ctx, "decode_body")
	if err := json.NewDecoder(r.Body).Decode(&m); err != nil {
		decodeSpan()
		utils.JSONError(w, http.StatusBadRequest, "invalid json")
		return
	}
	decodeSpan()

	// determine caller role and canonical author
	// resolve canonical author (from signature, or backend-provided body/header)
	authSpan := telemetry.StartSpan(ctx, "resolve_author")
	if author, code, msg := auth.ResolveAuthorFromRequest(r, m.Author); code != 0 {
		authSpan()
		utils.JSONError(w, code, msg)
		return
	} else {
		m.Author = author
	}
	authSpan()
	// Ensure message role is present. Default to "user" when omitted.
	if m.Role == "" {
		m.Role = "user"
	}
	// If no thread provided, create one explicitly via createThreadInternal
	if m.Thread == "" {
		createThreadSpan := telemetry.StartSpan(ctx, "create_thread")
		th, err := createThreadInternal(ctx, m.Author, defaultThreadTitle())
		createThreadSpan()
		if err != nil {
			utils.JSONError(w, http.StatusInternalServerError, "failed to create thread")
			return
		}
		// sync thread to message
		m.Thread = th.ID
	} else {
		// ensure provided thread exists and user is the author
		getThreadSpan := telemetry.StartSpan(ctx, "get_thread")
		s, err := store.GetThread(m.Thread)
		getThreadSpan()
		if err != nil {
			utils.JSONError(w, http.StatusNotFound, "thread not found")
			return
		}
		var th models.Thread
		if err := json.Unmarshal([]byte(s), &th); err != nil {
			utils.JSONError(w, http.StatusInternalServerError, "failed to parse thread")
			return
		}
		// Only allow creating if the user is the author, unless admin
		role := r.Header.Get("X-Role-Name")

		if role != "admin" && th.Author != m.Author {
			utils.JSONError(w, http.StatusForbidden, "author does not match thread")
			return
		}
	}

	// generate a message id
	m.ID = utils.GenID()
	if m.TS == 0 {
		m.TS = time.Now().UTC().UnixNano()
	}

	// prevent posting to deleted thread
	if sthr, err := store.GetThread(m.Thread); err == nil {
		var th models.Thread
		if err := json.Unmarshal([]byte(sthr), &th); err == nil {
			if th.Deleted && r.Header.Get("X-Role-Name") != "admin" {
				utils.JSONError(w, http.StatusForbidden, "thread deleted")
				return
			}
		}
	}

	// validate the message format
	validateSpan := telemetry.StartSpan(ctx, "validate_message")
	if err := validation.ValidateMessage(m); err != nil {
		validateSpan()
		utils.JSONError(w, http.StatusBadRequest, err.Error())
		return
	}
	validateSpan()

	// At this point the thread exists (we either created it above & validated the provided thread id & message).
	// save the message (span scoped to the DB write)
    saveSpan := telemetry.StartSpan(ctx, "save_message")
    if err := store.SaveMessage(ctx, m.Thread, m.ID, m); err != nil {
        saveSpan()
        utils.JSONError(w, http.StatusInternalServerError, err.Error())
        return
    }
	saveSpan()
	logger.Info("message_created", "thread", m.Thread, "id", m.ID)
	encodeSpan := telemetry.StartSpan(ctx, "encode_response")
	_ = json.NewEncoder(w).Encode(m)
	encodeSpan()
}

// listMessages handles GET /messages to list messages in a thread.
// Query parameters:
//   - "thread" (string, optional): thread ID to list messages from (default: "default").
//   - "limit" (int, optional): maximum number of most recent messages to return.
//
// Response: 200 with JSON object {thread, messages}, or 500 on error.
func listMessages(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	threadID := r.URL.Query().Get("thread")
	if threadID == "" {
		threadID = "default"
	}
	msgs, err := store.ListMessages(threadID)
	if err != nil {
		utils.JSONError(w, http.StatusInternalServerError, err.Error())
		return
	}
	if limStr := r.URL.Query().Get("limit"); limStr != "" {
		if lim, err := strconv.Atoi(limStr); err == nil && lim >= 0 && lim < len(msgs) {
			msgs = msgs[len(msgs)-lim:]
		}
	}
	// Build map of latest version per message id, then optionally filter deleted
	includeDeleted := r.URL.Query().Get("include_deleted") == "true"
	latest := make(map[string]models.Message)
	for _, s := range msgs {
		var mm models.Message
		if err := json.Unmarshal([]byte(s), &mm); err != nil {
			continue
		}
		cur, ok := latest[mm.ID]
		if !ok || mm.TS >= cur.TS {
			latest[mm.ID] = mm
		}
	}
	// Collect and sort by timestamp ascending
	out := make([]models.Message, 0, len(latest))
	for _, v := range latest {
		if v.Deleted && !includeDeleted {
			continue
		}
		out = append(out, v)
	}
	// sort by TS
	sort.Slice(out, func(i, j int) bool { return out[i].TS < out[j].TS })
	logger.Info("messages_list", "thread", threadID, "count", len(out))
	_ = json.NewEncoder(w).Encode(struct {
		Thread   string           `json:"thread"`
		Messages []models.Message `json:"messages"`
	}{Thread: threadID, Messages: out})
}

// listMessageVersions handles GET /threads/{threadID}/messages/{id}/versions
// or legacy GET /messages/{id}/versions when routed. It returns JSON objects
// for each stored version.
func listMessageVersions(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	vars := mux.Vars(r)
	id := vars["id"]
	threadID := vars["threadID"]

	// If threadID provided, ensure the message belongs to that thread.
	if threadID != "" {
		s, err := store.GetLatestMessage(id)
		if err != nil {
			http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
			return
		}
		var m models.Message
		if err := json.Unmarshal([]byte(s), &m); err != nil {
			http.Error(w, `{"error":"failed to parse message"}`, http.StatusInternalServerError)
			return
		}
		if m.Thread != threadID {
			http.Error(w, `{"error":"message not found in thread"}`, http.StatusNotFound)
			return
		}
	}

	vs, err := store.ListMessageVersions(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	out := make([]json.RawMessage, 0, len(vs))
	for _, s := range vs {
		out = append(out, json.RawMessage(s))
	}
	_ = json.NewEncoder(w).Encode(struct {
		ID       string            `json:"id"`
		Versions []json.RawMessage `json:"versions"`
	}{ID: id, Versions: out})
}

// getReactions handles GET /threads/{threadID}/messages/{id}/reactions
func getReactions(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["id"]
	threadID := vars["threadID"]

	w.Header().Set("Content-Type", "application/json")
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}
	var m models.Message
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		http.Error(w, `{"error":"invalid stored message"}`, http.StatusInternalServerError)
		return
	}
	if threadID != "" && m.Thread != threadID {
		http.Error(w, `{"error":"message not found in thread"}`, http.StatusNotFound)
		return
	}
	out := make([]struct {
		ID       string `json:"id"`
		Reaction string `json:"reaction"`
	}, 0)
	for k, v := range m.Reactions {
		out = append(out, struct {
			ID       string `json:"id"`
			Reaction string `json:"reaction"`
		}{ID: k, Reaction: v})
	}
	_ = json.NewEncoder(w).Encode(struct {
		ID        string      `json:"id"`
		Reactions interface{} `json:"reactions"`
	}{ID: id, Reactions: out})
}

// addReaction handles POST /threads/{threadID}/messages/{id}/reactions
func addReaction(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["id"]
	threadID := vars["threadID"]

	w.Header().Set("Content-Type", "application/json")
	var payload struct {
		ID       string `json:"id"`
		Reaction string `json:"reaction"`
	}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		http.Error(w, `{"error":"invalid json"}`, http.StatusBadRequest)
		return
	}
	identity := payload.ID
	if identity == "" {
		identity = r.Header.Get("X-Identity")
	}
	if identity == "" || payload.Reaction == "" {
		http.Error(w, `{"error":"missing id or reaction"}`, http.StatusBadRequest)
		return
	}
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}
	var m models.Message
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		http.Error(w, `{"error":"invalid stored message"}`, http.StatusInternalServerError)
		return
	}
	if threadID != "" && m.Thread != threadID {
		http.Error(w, `{"error":"message not found in thread"}`, http.StatusNotFound)
		return
	}
	if m.Reactions == nil {
		m.Reactions = map[string]string{}
	}
	m.Reactions[identity] = payload.Reaction
	m.TS = time.Now().UTC().UnixNano()

    if err := store.SaveMessage(r.Context(), m.Thread, m.ID, m); err != nil {
        http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
        return
    }
	_ = json.NewEncoder(w).Encode(m)
}

// deleteReaction handles DELETE /threads/{threadID}/messages/{id}/reactions/{identity}
func deleteReaction(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id := vars["id"]
	identity := vars["identity"]
	threadID := vars["threadID"]

	w.Header().Set("Content-Type", "application/json")
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}
	var m models.Message
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		http.Error(w, `{"error":"invalid stored message"}`, http.StatusInternalServerError)
		return
	}
	if threadID != "" && m.Thread != threadID {
		http.Error(w, `{"error":"message not found in thread"}`, http.StatusNotFound)
		return
	}
	if m.Reactions != nil {
		delete(m.Reactions, identity)
	}
	m.TS = time.Now().UTC().UnixNano()

    if err := store.SaveMessage(r.Context(), m.Thread, m.ID, m); err != nil {
        http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
        return
    }
	w.WriteHeader(http.StatusNoContent)
}
