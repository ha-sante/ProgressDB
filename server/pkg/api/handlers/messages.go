package handlers

import (
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"log/slog"
	"progressdb/pkg/auth"
	"progressdb/pkg/models"
	"progressdb/pkg/store"
	"progressdb/pkg/utils"
	"progressdb/pkg/validation"

	"github.com/gorilla/mux"
	"sort"
)

// RegisterMessages registers HTTP handlers for message-related endpoints.
// This includes endpoints for creating, listing, retrieving, updating, and deleting messages,
// as well as managing message versions and reactions.
func RegisterMessages(r *mux.Router) {
	// /v1/messages
	r.HandleFunc("/messages", createMessage).Methods(http.MethodPost)
	r.HandleFunc("/messages", listMessages).Methods(http.MethodGet)

	// /v1/messages/{id}
	r.HandleFunc("/messages/{id}", getMessage).Methods(http.MethodGet)
	r.HandleFunc("/messages/{id}", updateMessage).Methods(http.MethodPut)
	r.HandleFunc("/messages/{id}", deleteMessage).Methods(http.MethodDelete)
	r.HandleFunc("/messages/{id}/versions", listMessageVersions).Methods(http.MethodGet)

	// /v1/messages/{id}/reactions
	r.HandleFunc("/messages/{id}/reactions", getReactions).Methods(http.MethodGet)
	r.HandleFunc("/messages/{id}/reactions", addReaction).Methods(http.MethodPost)
	r.HandleFunc("/messages/{id}/reactions/{identity}", deleteReaction).Methods(http.MethodDelete)
}

// createMessage handles POST /messages to create a new message.
// Request body: JSON object representing a models.Message.
// Required fields in body: "body" (string), "author" (string).
// Optional fields: "thread" (string, if omitted a new thread is created), "id" (string, autogenerated if omitted), "ts" (int64, autogenerated if omitted).
// Response: 200 with created message JSON, or 400/500 on error.
func createMessage(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	var m models.Message
	if err := json.NewDecoder(r.Body).Decode(&m); err != nil {
		http.Error(w, `{"error":"invalid json"}`, http.StatusBadRequest)
		return
	}
    // determine caller role and canonical author
    // resolve canonical author (from signature, or backend-provided body/header)
    if author, code, msg := auth.ResolveAuthorFromRequest(r, m.Author); code != 0 {
        http.Error(w, msg, code)
        return
    } else {
        m.Author = author
    }
    // Ensure message role is present. Default to "user" when omitted.
    if m.Role == "" {
        m.Role = "user"
    }
	// Always generate server-side IDs for messages to avoid client-side impersonation
	if m.Thread == "" {
		m.Thread = utils.GenThreadID()
	}
	m.ID = utils.GenID()
	if m.TS == 0 {
		m.TS = time.Now().UTC().UnixNano()
	}
	// prevent posting to deleted thread
	if sthr, err := store.GetThread(m.Thread); err == nil {
		var th models.Thread
		if err := json.Unmarshal([]byte(sthr), &th); err == nil {
			if th.Deleted && r.Header.Get("X-Role-Name") != "admin" {
				http.Error(w, `{"error":"thread deleted"}`, http.StatusForbidden)
				return
			}
		}
	}
	if err := validation.ValidateMessage(m); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusBadRequest)
		return
	}
	b, _ := json.Marshal(m)
	if err := store.SaveMessage(m.Thread, m.ID, string(b)); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	// ensure thread meta
	if sthr, err := store.GetThread(m.Thread); err != nil {
		// create a minimal thread metadata record and set the author from the verified message author
		th := models.Thread{ID: m.Thread, Title: defaultThreadTitle(), Author: m.Author, Slug: "", CreatedTS: m.TS, UpdatedTS: m.TS}
		th.Slug = utils.MakeSlug(th.Title, th.ID)
		_ = store.SaveThread(th.ID, func() string { b, _ := json.Marshal(th); return string(b) }())
	} else {
		var th models.Thread
		if err := json.Unmarshal([]byte(sthr), &th); err == nil {
			th.UpdatedTS = m.TS
			_ = store.SaveThread(th.ID, func() string { b, _ := json.Marshal(th); return string(b) }())
		}
	}
	slog.Info("message_created", "thread", m.Thread, "id", m.ID)
	_ = json.NewEncoder(w).Encode(m)
}

// listMessages handles GET /messages to list messages in a thread.
// Query parameters:
//   - "thread" (string, optional): thread ID to list messages from (default: "default").
//   - "limit" (int, optional): maximum number of most recent messages to return.
//
// Response: 200 with JSON object {thread, messages}, or 500 on error.
func listMessages(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	threadID := r.URL.Query().Get("thread")
	if threadID == "" {
		threadID = "default"
	}
	msgs, err := store.ListMessages(threadID)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	if limStr := r.URL.Query().Get("limit"); limStr != "" {
		if lim, err := strconv.Atoi(limStr); err == nil && lim >= 0 && lim < len(msgs) {
			msgs = msgs[len(msgs)-lim:]
		}
	}
	// Build map of latest version per message id, then optionally filter deleted
	includeDeleted := r.URL.Query().Get("include_deleted") == "true"
	latest := make(map[string]models.Message)
	for _, s := range msgs {
		var mm models.Message
		if err := json.Unmarshal([]byte(s), &mm); err != nil {
			continue
		}
		cur, ok := latest[mm.ID]
		if !ok || mm.TS >= cur.TS {
			latest[mm.ID] = mm
		}
	}
	// Collect and sort by timestamp ascending
	out := make([]models.Message, 0, len(latest))
	for _, v := range latest {
		if v.Deleted && !includeDeleted {
			continue
		}
		out = append(out, v)
	}
	// sort by TS
	sort.Slice(out, func(i, j int) bool { return out[i].TS < out[j].TS })
	slog.Info("messages_list", "thread", threadID, "count", len(out))
	_ = json.NewEncoder(w).Encode(struct {
		Thread   string           `json:"thread"`
		Messages []models.Message `json:"messages"`
	}{Thread: threadID, Messages: out})
}

// getMessage handles GET /messages/{id} to retrieve the latest version of a message by ID.
// Path parameter: "id" (string, required): message ID.
// Response: 200 with message JSON, or 404 if not found.
func getMessage(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	id := mux.Vars(r)["id"]
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}
	_, _ = w.Write([]byte(s))
}

// updateMessage handles PUT /messages/{id} to update a message by ID.
// Path parameter: "id" (string, required): message ID.
// Request body: JSON object representing a models.Message.
// Required fields in body: "body" (string), "author" (string).
// Optional fields: "thread" (string, if omitted a new thread is created), "ts" (int64, autogenerated if omitted).
// Response: 200 with updated message JSON, or 400/500 on error.
func updateMessage(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	id := mux.Vars(r)["id"]
	var m models.Message
	if err := json.NewDecoder(r.Body).Decode(&m); err != nil {
		http.Error(w, `{"error":"invalid json"}`, http.StatusBadRequest)
		return
	}
    m.ID = id
    // determine caller role and canonical author
    if author, code, msg := auth.ResolveAuthorFromRequest(r, m.Author); code != 0 {
        http.Error(w, msg, code)
        return
    } else {
        m.Author = author
    }
    // Ensure role is present; default to "user" if omitted
    if m.Role == "" {
        m.Role = "user"
    }
	if m.Thread == "" {
		m.Thread = utils.GenThreadID()
	}
	if m.TS == 0 {
		m.TS = time.Now().UTC().UnixNano()
	}
	if err := validation.ValidateMessage(m); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusBadRequest)
		return
	}
	b, _ := json.Marshal(m)
	if err := store.SaveMessage(m.Thread, m.ID, string(b)); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	// Ensure thread meta exists or update UpdatedTS
	if sthr, err := store.GetThread(m.Thread); err != nil {
		// create a minimal thread metadata record and set the author from the verified message author
		th := models.Thread{ID: m.Thread, Title: defaultThreadTitle(), Author: m.Author, Slug: "", CreatedTS: m.TS, UpdatedTS: m.TS}
		th.Slug = utils.MakeSlug(th.Title, th.ID)
		_ = store.SaveThread(th.ID, func() string { b, _ := json.Marshal(th); return string(b) }())
	} else {
		var th models.Thread
		if err := json.Unmarshal([]byte(sthr), &th); err == nil {
			th.UpdatedTS = m.TS
			_ = store.SaveThread(th.ID, func() string { b, _ := json.Marshal(th); return string(b) }())
		}
	}
	_ = json.NewEncoder(w).Encode(m)
}

// deleteMessage handles DELETE /messages/{id} to mark a message as deleted.
// Path parameter: "id" (string, required): message ID.
// Response: 204 No Content on success, 404 if not found, or 500 on error.
func deleteMessage(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	id := mux.Vars(r)["id"]
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}
	var m models.Message
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		http.Error(w, `{"error":"invalid stored message"}`, http.StatusInternalServerError)
		return
	}
    // verify author owns the message (or is admin)
    author, code, msg := auth.ResolveAuthorFromRequest(r, "")
    if code != 0 {
        http.Error(w, msg, code)
        return
    }
    role := r.Header.Get("X-Role-Name")
    if role != "admin" && m.Author != author {
        http.Error(w, `{"error":"author does not match"}`, http.StatusForbidden)
        return
    }
	m.Deleted = true
	m.TS = time.Now().UTC().UnixNano()
	b, _ := json.Marshal(m)
	if err := store.SaveMessage(m.Thread, m.ID, string(b)); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

// listMessageVersions handles GET /messages/{id}/versions to list all versions of a message.
// Path parameter: "id" (string, required): message ID.
// Response: 200 with JSON object {id, versions}, or 500 on error.
func listMessageVersions(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	id := mux.Vars(r)["id"]
	vs, err := store.ListMessageVersions(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	// Return versions as JSON objects (not JSON-encoded strings). Convert
	// stored JSON strings to json.RawMessage so the encoder emits objects.
	out := make([]json.RawMessage, 0, len(vs))
	for _, s := range vs {
		out = append(out, json.RawMessage(s))
	}
	_ = json.NewEncoder(w).Encode(struct {
		ID       string            `json:"id"`
		Versions []json.RawMessage `json:"versions"`
	}{ID: id, Versions: out})
}


// getReactions handles GET /messages/{id}/reactions to list all reactions for a message.
// Path parameter: "id" (string, required): message ID.
// Response: 200 with JSON object {id, reactions}, or 404/500 on error.
func getReactions(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	id := mux.Vars(r)["id"]
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}
	var m models.Message
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		http.Error(w, `{"error":"invalid stored message"}`, http.StatusInternalServerError)
		return
	}
	out := make([]struct {
		ID       string `json:"id"`
		Reaction string `json:"reaction"`
	}, 0)
	for k, v := range m.Reactions {
		out = append(out, struct {
			ID       string `json:"id"`
			Reaction string `json:"reaction"`
		}{ID: k, Reaction: v})
	}
	_ = json.NewEncoder(w).Encode(struct {
		ID        string      `json:"id"`
		Reactions interface{} `json:"reactions"`
	}{ID: id, Reactions: out})
}

// addReaction handles POST /messages/{id}/reactions to add or update a reaction for a message.
// Path parameter: "id" (string, required): message ID.
// Request body: JSON object with fields:
//   - "id" (string, required if X-Identity header not set): identity of the reactor
//   - "reaction" (string, required): the reaction value
//
// Alternatively, "id" can be provided via the "X-Identity" header.
// Response: 200 with updated message JSON, or 400/404/500 on error.
func addReaction(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	id := mux.Vars(r)["id"]
	var payload struct {
		ID       string `json:"id"`
		Reaction string `json:"reaction"`
	}
	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		http.Error(w, `{"error":"invalid json"}`, http.StatusBadRequest)
		return
	}
	identity := payload.ID
	if identity == "" {
		identity = r.Header.Get("X-Identity")
	}
	if identity == "" || payload.Reaction == "" {
		http.Error(w, `{"error":"missing id or reaction"}`, http.StatusBadRequest)
		return
	}
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}
	var m models.Message
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		http.Error(w, `{"error":"invalid stored message"}`, http.StatusInternalServerError)
		return
	}
	if m.Reactions == nil {
		m.Reactions = map[string]string{}
	}
	m.Reactions[identity] = payload.Reaction
	m.TS = time.Now().UTC().UnixNano()
	b, _ := json.Marshal(m)
	if err := store.SaveMessage(m.Thread, m.ID, string(b)); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	_ = json.NewEncoder(w).Encode(m)
}

// deleteReaction handles DELETE /messages/{id}/reactions/{identity} to remove a reaction from a message.
// Path parameters:
//   - "id" (string, required): message ID
//   - "identity" (string, required): identity of the reactor whose reaction should be removed
//
// Response: 204 No Content on success, 404 if not found, or 500 on error.
func deleteReaction(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	vars := mux.Vars(r)
	id := vars["id"]
	identity := vars["identity"]
	s, err := store.GetLatestMessage(id)
	if err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusNotFound)
		return
	}
	var m models.Message
	if err := json.Unmarshal([]byte(s), &m); err != nil {
		http.Error(w, `{"error":"invalid stored message"}`, http.StatusInternalServerError)
		return
	}
	if m.Reactions != nil {
		delete(m.Reactions, identity)
	}
	m.TS = time.Now().UTC().UnixNano()
	b, _ := json.Marshal(m)
	if err := store.SaveMessage(m.Thread, m.ID, string(b)); err != nil {
		http.Error(w, `{"error":"`+err.Error()+`"}`, http.StatusInternalServerError)
		return
	}
	w.WriteHeader(http.StatusNoContent)
}

// thread-scoped message handlers moved to handlers/threads.go
